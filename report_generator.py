#!/usr/bin/env python3
"""
Report Generator Module for ARR-Agent
Generates comprehensive Markdown reports with MITRE ATT&CK mappings
"""

import json
import sqlite3
from datetime import datetime
from pathlib import Path

class ReportGenerator:
    """Professional report generator"""
    
    def __init__(self, agent):
        self.agent = agent
        
        # MITRE ATT&CK mappings
        self.mitre_mappings = {
            'port_scan': {
                'tactic': 'TA0043 - Reconnaissance',
                'technique': 'T1046 - Network Service Scanning',
                'description': 'Adversaries may attempt to get a listing of services running on remote hosts'
            },
            'dns_enum': {
                'tactic': 'TA0043 - Reconnaissance',
                'technique': 'T1590.002 - DNS/Passive DNS',
                'description': 'Adversaries may search DNS data for information about victims'
            },
            'subdomain': {
                'tactic': 'TA0043 - Reconnaissance',
                'technique': 'T1590.001 - Domain Properties',
                'description': 'Adversaries may gather information about victim domains'
            },
            'secrets': {
                'tactic': 'TA0006 - Credential Access',
                'technique': 'T1552.001 - Credentials In Files',
                'description': 'Adversaries may search public code repositories for credentials'
            }
        }
    
    def generate(self):
        """Generate comprehensive Markdown report"""
        report_path = self.agent.output_dir / f"ARR_Report_{self.agent.session_id}.md"
        
        with open(report_path, 'w', encoding='utf-8') as f:
            # Executive Summary
            f.write(self._generate_header())
            f.write(self._generate_executive_summary())
            
            # Findings by Module
            f.write(self._generate_port_findings())
            f.write(self._generate_dns_findings())
            f.write(self._generate_subdomain_findings())
            f.write(self._generate_secret_findings())
            
            # Risk Analysis
            f.write(self._generate_risk_analysis())
            f.write(self._generate_attack_paths())
            
            # MITRE ATT&CK Mapping
            f.write(self._generate_mitre_mapping())
            
            # Recommendations
            f.write(self._generate_recommendations())
            
            # Appendix
            f.write(self._generate_appendix())
        
        return report_path
    
    def _generate_header(self):
        """Generate report header"""
        return f"""# ARR-Agent Reconnaissance Report

**Target:** {self.agent.target}  
**Report Date:** {datetime.now().strftime("%Y-%m-%d %H:%M:%S")}  
**Session ID:** {self.agent.session_id}  
**Generated by:** Autonomous Reconnaissance & Reporting Agent (ARR-Agent)

---

"""
    
    def _generate_executive_summary(self):
        """Generate executive summary"""
        total_ports = len(self.agent.findings['ports'])
        total_subdomains = len(self.agent.findings['subdomains'])
        total_secrets = len(self.agent.findings['secrets'])
        
        # Count high-risk findings
        high_risk_count = sum(1 for r in self.agent.findings.get('risks', []) 
                             if r['score'] >= 7.0)
        critical_count = sum(1 for r in self.agent.findings.get('risks', []) 
                            if r['score'] >= 9.0)
        
        return f"""## Executive Summary

This report presents findings from automated reconnaissance conducted against **{self.agent.target}**. The assessment utilized multiple OSINT techniques including port scanning, DNS enumeration, subdomain discovery, and public repository analysis.

### Key Findings Summary

| Category | Count | Critical | High Risk |
|----------|-------|----------|-----------|
| Open Ports | {total_ports} | - | - |
| Subdomains | {total_subdomains} | - | - |
| Exposed Secrets | {total_secrets} | {critical_count} | {high_risk_count} |

### Overall Risk Assessment

"""
    
    def _generate_port_findings(self):
        """Generate port scan findings section"""
        if not self.agent.findings['ports']:
            return "\n## Port Scan Results\n\nNo open ports discovered.\n\n---\n\n"
        
        section = "\n## Port Scan Results\n\n"
        section += "### Discovered Services\n\n"
        section += "| Host | Port | Protocol | Service | Version | Risk |\n"
        section += "|------|------|----------|---------|---------|------|\n"
        
        # Get risk scores
        risks = {r['id']: r for r in self.agent.findings.get('risks', []) 
                if r['type'] == 'port'}
        
        for port in sorted(self.agent.findings['ports'], 
                          key=lambda x: risks.get(x['id'], {}).get('score', 0), 
                          reverse=True):
            risk_info = risks.get(port['id'], {})
            risk_score = risk_info.get('score', 0)
            criticality = self._get_criticality(risk_score)
            
            section += f"| {port.get('host', 'N/A')} "
            section += f"| {port.get('port', 'N/A')} "
            section += f"| {port.get('protocol', 'N/A')} "
            section += f"| {port.get('service', 'N/A')} "
            section += f"| {port.get('version', 'N/A')} "
            section += f"| {criticality} ({risk_score:.1f}) |\n"
        
        section += "\n### MITRE ATT&CK Mapping\n\n"
        section += f"- **Tactic:** {self.mitre_mappings['port_scan']['tactic']}\n"
        section += f"- **Technique:** {self.mitre_mappings['port_scan']['technique']}\n"
        section += f"- **Description:** {self.mitre_mappings['port_scan']['description']}\n\n"
        
        section += "---\n\n"
        return section
    
    def _generate_dns_findings(self):
        """Generate DNS enumeration findings"""
        if not self.agent.findings['dns']:
            return "\n## DNS Enumeration Results\n\nNo DNS records discovered.\n\n---\n\n"
        
        section = "\n## DNS Enumeration Results\n\n"
        
        if 'primary_ip' in self.agent.findings['dns']:
            section += f"**Primary IP:** {self.agent.findings['dns']['primary_ip']}\n\n"
        
        # Query database for DNS records
        conn = sqlite3.connect(self.agent.db_path)
        cursor = conn.cursor()
        cursor.execute("SELECT record_type, value FROM dns_records WHERE domain = ?", 
                      (self.agent.target,))
        records = cursor.fetchall()
        conn.close()
        
        if records:
            # Group by type
            record_types = {}
            for record_type, value in records:
                if record_type not in record_types:
                    record_types[record_type] = []
                record_types[record_type].append(value)
            
            for rtype in sorted(record_types.keys()):
                if rtype != 'WHOIS':  # Handle WHOIS separately
                    section += f"### {rtype} Records\n\n"
                    for value in record_types[rtype]:
                        section += f"- {value}\n"
                    section += "\n"
        
        section += "### MITRE ATT&CK Mapping\n\n"
        section += f"- **Tactic:** {self.mitre_mappings['dns_enum']['tactic']}\n"
        section += f"- **Technique:** {self.mitre_mappings['dns_enum']['technique']}\n"
        section += f"- **Description:** {self.mitre_mappings['dns_enum']['description']}\n\n"
        
        section += "---\n\n"
        return section
    
    def _generate_subdomain_findings(self):
        """Generate subdomain discovery findings"""
        if not self.agent.findings['subdomains']:
            return "\n## Subdomain Discovery Results\n\nNo subdomains discovered.\n\n---\n\n"
        
        section = "\n## Subdomain Discovery Results\n\n"
        section += f"**Total Subdomains Found:** {len(self.agent.findings['subdomains'])}\n\n"
        
        section += "### Discovered Subdomains\n\n"
        section += "| Subdomain | IP Address | Risk |\n"
        section += "|-----------|------------|------|\n"
        
        # Get risk scores
        risks = {r['id']: r for r in self.agent.findings.get('risks', []) 
                if r['type'] == 'subdomain'}
        
        for subdomain in sorted(self.agent.findings['subdomains'],
                               key=lambda x: risks.get(x['id'], {}).get('score', 0),
                               reverse=True):
            risk_info = risks.get(subdomain['id'], {})
            risk_score = risk_info.get('score', 0)
            criticality = self._get_criticality(risk_score)
            
            section += f"| {subdomain.get('subdomain', 'N/A')} "
            section += f"| {subdomain.get('ip', 'N/A')} "
            section += f"| {criticality} ({risk_score:.1f}) |\n"
        
        section += "\n### MITRE ATT&CK Mapping\n\n"
        section += f"- **Tactic:** {self.mitre_mappings['subdomain']['tactic']}\n"
        section += f"- **Technique:** {self.mitre_mappings['subdomain']['technique']}\n"
        section += f"- **Description:** {self.mitre_mappings['subdomain']['description']}\n\n"
        
        section += "---\n\n"
        return section
    
    def _generate_secret_findings(self):
        """Generate exposed secrets findings"""
        if not self.agent.findings['secrets']:
            return "\n## GitHub Secret Scanning Results\n\nNo exposed secrets found.\n\n---\n\n"
        
        section = "\n## GitHub Secret Scanning Results\n\n"
        section += f"âš ï¸ **CRITICAL: {len(self.agent.findings['secrets'])} exposed secrets discovered**\n\n"
        
        section += "### Exposed Secrets\n\n"
        
        # Get risk scores
        risks = {r['id']: r for r in self.agent.findings.get('risks', []) 
                if r['type'] == 'secret'}
        
        for secret in sorted(self.agent.findings['secrets'],
                            key=lambda x: risks.get(x['id'], {}).get('score', 0),
                            reverse=True):
            risk_info = risks.get(secret['id'], {})
            risk_score = risk_info.get('score', 0)
            criticality = self._get_criticality(risk_score)
            
            section += f"#### [{criticality}] {secret.get('type', 'Unknown').upper()} (Risk: {risk_score:.1f})\n\n"
            section += f"- **Source:** {secret.get('repo', 'Unknown')}/{secret.get('file', 'Unknown')}\n"
            section += f"- **Value:** `{secret.get('value', 'N/A')[:50]}...`\n"
            if 'url' in secret:
                section += f"- **URL:** {secret['url']}\n"
            section += "\n"
        
        section += "### MITRE ATT&CK Mapping\n\n"
        section += f"- **Tactic:** {self.mitre_mappings['secrets']['tactic']}\n"
        section += f"- **Technique:** {self.mitre_mappings['secrets']['technique']}\n"
        section += f"- **Description:** {self.mitre_mappings['secrets']['description']}\n\n"
        
        section += "---\n\n"
        return section
    
    def _generate_risk_analysis(self):
        """Generate risk analysis section"""
        section = "\n## Risk Analysis\n\n"
        
        risks = self.agent.findings.get('risks', [])
        
        if not risks:
            return section + "No risk analysis available.\n\n---\n\n"
        
        # Count by criticality
        critical = sum(1 for r in risks if r['score'] >= 9.0)
        high = sum(1 for r in risks if 7.0 <= r['score'] < 9.0)
        medium = sum(1 for r in risks if 5.0 <= r['score'] < 7.0)
        low = sum(1 for r in risks if r['score'] < 5.0)
        
        section += "### Risk Distribution\n\n"
        section += f"- **Critical (9.0-10.0):** {critical} findings\n"
        section += f"- **High (7.0-8.9):** {high} findings\n"
        section += f"- **Medium (5.0-6.9):** {medium} findings\n"
        section += f"- **Low (0-4.9):** {low} findings\n\n"
        
        section += "### Top 10 Highest Risk Findings\n\n"
        
        top_risks = sorted(risks, key=lambda x: x['score'], reverse=True)[:10]
        
        for i, risk in enumerate(top_risks, 1):
            criticality = self._get_criticality(risk['score'])
            section += f"{i}. **[{criticality}]** {risk['type'].upper()} "
            section += f"(Risk Score: {risk['score']:.1f})\n"
            if risk.get('factors'):
                section += f"   - Factors: {', '.join(risk['factors'][:3])}\n"
            section += "\n"
        
        section += "---\n\n"
        return section
    
    def _generate_attack_paths(self):
        """Generate attack path analysis"""
        section = "\n## Identified Attack Paths\n\n"
        
        attack_paths = self.agent.findings.get('attack_paths', [])
        
        if not attack_paths:
            return section + "No specific attack paths identified based on current findings.\n\n---\n\n"
        
        for i, path in enumerate(attack_paths, 1):
            section += f"### Attack Path {i}: {path['path']}\n\n"
            section += f"**Risk Level:** {path['risk']}/10\n\n"
            section += "**Attack Steps:**\n\n"
            for step in path['steps']:
                section += f"{step}\n"
            section += "\n"
        
        section += "---\n\n"
        return section
    
    def _generate_mitre_mapping(self):
        """Generate MITRE ATT&CK mapping summary"""
        section = "\n## MITRE ATT&CK Framework Mapping\n\n"
        section += "### Tactics and Techniques Observed\n\n"
        
        section += "| Tactic | Technique | Module |\n"
        section += "|--------|-----------|--------|\n"
        
        if self.agent.findings['ports']:
            m = self.mitre_mappings['port_scan']
            section += f"| {m['tactic']} | {m['technique']} | Port Scanning |\n"
        
        if self.agent.findings['dns']:
            m = self.mitre_mappings['dns_enum']
            section += f"| {m['tactic']} | {m['technique']} | DNS Enumeration |\n"
        
        if self.agent.findings['subdomains']:
            m = self.mitre_mappings['subdomain']
            section += f"| {m['tactic']} | {m['technique']} | Subdomain Discovery |\n"
        
        if self.agent.findings['secrets']:
            m = self.mitre_mappings['secrets']
            section += f"| {m['tactic']} | {m['technique']} | Secret Scanning |\n"
        
        section += "\n---\n\n"
        return section
    
    def _generate_recommendations(self):
        """Generate security recommendations"""
        section = "\n## Recommendations\n\n"
        
        section += "### Immediate Actions\n\n"
        
        # Port-based recommendations
        if self.agent.findings['ports']:
            section += "#### Network Security\n\n"
            section += "1. Review all exposed services and close unnecessary ports\n"
            section += "2. Implement network segmentation to limit exposure\n"
            section += "3. Enable service authentication where missing\n"
            section += "4. Update services to latest versions\n\n"
        
        # Secret-based recommendations
        if self.agent.findings['secrets']:
            section += "#### Credential Management\n\n"
            section += "1. **IMMEDIATE:** Rotate all exposed credentials found in public repositories\n"
            section += "2. Implement secrets management solution (e.g., HashiCorp Vault, AWS Secrets Manager)\n"
            section += "3. Enable GitHub secret scanning and push protection\n"
            section += "4. Review and remove all historical commits containing secrets\n"
            section += "5. Conduct security awareness training on secure coding practices\n\n"
        
        # Subdomain recommendations
        if self.agent.findings['subdomains']:
            section += "#### Domain Management\n\n"
            section += "1. Review all discovered subdomains for business necessity\n"
            section += "2. Decommission unused subdomains\n"
            section += "3. Implement monitoring for new subdomain creation\n"
            section += "4. Ensure development environments are not publicly accessible\n\n"
        
        section += "### Long-term Strategy\n\n"
        section += "1. Implement continuous attack surface monitoring\n"
        section += "2. Establish regular vulnerability scanning schedules\n"
        section += "3. Develop and maintain asset inventory\n"
        section += "4. Create incident response procedures for credential leaks\n"
        section += "5. Implement zero-trust architecture where possible\n\n"
        
        section += "---\n\n"
        return section
    
    def _generate_appendix(self):
        """Generate appendix with technical details"""
        section = "\n## Appendix\n\n"
        section += f"### Scan Details\n\n"
        section += f"- **Target:** {self.agent.target}\n"
        section += f"- **Session ID:** {self.agent.session_id}\n"
        section += f"- **Database:** {self.agent.db_path}\n"
        section += f"- **Report Generated:** {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n\n"
        
        section += "### Tools and Techniques\n\n"
        section += "- Port Scanning: nmap integration\n"
        section += "- DNS Enumeration: nslookup, socket library\n"
        section += "- Subdomain Discovery: Certificate Transparency logs, common name bruteforce\n"
        section += "- Secret Scanning: GitHub Code Search API, regex pattern matching\n"
        section += "- Risk Scoring: ML-based correlation and weighting algorithm\n\n"
        
        section += "---\n\n"
        section += "*End of Report*\n"
        
        return section
    
    def _get_criticality(self, risk_score):
        """Convert risk score to criticality level"""
        if risk_score >= 9.0:
            return "ğŸ”´ CRITICAL"
        elif risk_score >= 7.0:
            return "ğŸŸ  HIGH"
        elif risk_score >= 5.0:
            return "ğŸŸ¡ MEDIUM"
        else:
            return "ğŸŸ¢ LOW"